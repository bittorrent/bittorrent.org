:BEP: 52
:Title: Encrypted Torrent Payload
:Version: $Revision$
:Last-Modified: $Date$
:Author:  The 8472 <the8472.bep@infinite-source.de>
:Status:  Draft
:Type:  Standards Track
:Content-Type: text/x-rst
:Created: 04-Oct-2015
:Post-History: 


Abstract
========

This BEP specifies a way to apply symmetric encryption to torrent payload at the storage layer and additionally encrypt some metadata with the following goals:

* confidentiality
* limited privacy

and non-goals:

* forward-secrecy
* anonymity
* signature-based authentication, already covered by BEP 35 [#BEP-35]_
* authentication of peer connections


.. contents::
  


Rationale
=========

In general BitTorrent swarms are an open system well-suited for mass-distribution of data to the public.

Some use-cases require that the data is only distributed to a closed, trusted group of peers.
In other cases the content may be meant for open distribution within a community without intent of announcing the content to the whole world. This is analogous to web content that is open to human visitors but requests via robots.txt that it should not be announced to the world by web crawlers.   


While the private flag [#BEP-27]_ may be sufficient in a controlled environment to prevent information about the torrent (e.g. its infohash) from escaping and thus preventing others from connecting to the swarm this is a very brittle form of security which also prevents the use of public infrastructure such as open trackers, PEX or the DHT.
Similarly Message Stream Encryption provides limited protection from passive eavesdroppers on the network layer but does not prevent the infohash from escaping.   


Instead of attempting to restrict access to the swarm or metadata this BEP proposes to make all data opaque to 3rd parties by encrypting it with a shared secret that is not available through any torrent-related protocol, i.e. must be obtained separately by the user.

In principle the same properties can be provided by simply storing the data in an encrypted archive and using a nondescript filename, but that requires users to store the data twice or to use additional filesystem layers to transparently access the data, which is even more cumbersome when encryption is involved. It also prevents bittorrent clients from reusing already-downloaded files in a multi-file torrent. 

Metadata format
===============


.. parsed-literal::

    {
      info: {
        enc mac: *<32bytes of hmac output (string)>*,
        encrypted: {
          salt: *<32bytes of random binary data (string)>*,
          shadow: *<bencoded-then-encrypted dictionary (string)>*,
          v: *<version (integer)>*,
        },
        length: *<unchanged>*,
        name: *<public name (string)>*,
        piece length: *<unchanged>*
        pieces: *<N×20 bytes, piece hashes of the payload ciphertext (string)>*
      },
    }


``salt``
  a new, unique value must be chosen whenever the encrypted contents of a torrent are created or modified. It must be generated by a cryptographically secure RNG. Reuse, e.g. in a decrypt-modify-encrypt operation, would compromise the data. 

``v``
  The protocol version used to encrypt the torrent, currently *1*. New versions may be introduced by updates to this BEP if cryptographic weaknesses necessitate incompatible changes. Implementations should check if they support the version indicated in the metadata file and otherwise inform the user that they can download the data but not decrypt it.

``shadow``
  bencoded-then-encrypted dictionary whose key-value pairs shadow entries in the info dictionary.

``enc mac``
  message authentication code covering parts of the info dictionary

``name``
  the name field is a mandatory part of BEP 3 [#BEP-3]_. A placeholder MUST be provided. An implementation may either generate a random string consisting of filesystem-friendly characters or allow the user to choose a public name that reveals less information than the shadow name.

``length``
  The info dictionary describes the piece space layout in its ciphertext form. Currently there is no need for anything but a contiguous range of pieces, therefore the info dictionary MUST be created in single file mode.
  Future revisions of this BEP may change this requirement if non-contiguous ciphertext representations become necessary.
  
Shadow Dictionary
-----------------

While the info dictionary represents the torrent in its ciphertext form the shadow dictionary represents the plaintext.
In general entries in the shadow dictionary have the same semantics as keys in the info dictionary and take precedence over them,
with the restriction that implementations should only shadow a whitelist of keys for which they have a shadowing strategy and ignore other keys.

At a minimum clients should support shadowing of the following info dictionary keys: ``length``, ``files``, ``name``, ``comment``.
To protect privacy shadowing should also be used for any implementation-specific keys that reveal information about the payload.

Additionally clients should embed BEP 47 [#BEP-47]_ ``sha1`` values of the plaintext files into the shadow dictionary to simplify deduplication, which would otherwise have to attempt encrypting candidate files before checking them against the piece hashes which represent the ciphertext.


.. parsed-literal::

    {
      comment: *<optional, string>*,
      length: *<integer>*,
      name: *<string>*,
      files: *<list of dictionaries>*,
      ...
    }

``length`` or ``files``
  These fields represent the plaintext file layout in single or multi-file layout. This means that while the ciphertext is represented as a single file the plaintext can have a different layout.
  The plaintext length may be shorter than the ciphertext so that the ciphertext length can be rounded up to an integer multiple of the piece length to obfuscate file sizes. The plaintext is zero-padded in that case. BEP 47 [#BEP-47]_ can also be used for this purpose in multi-file mode, but since there currently is no way to pad in single-file mode this discrepancy is allowed.  
  
Interaction with paddings
-------------------------

Since the public representation is single-file there is no padding in the ciphertext.

The shadow file layout can contain padding files or implicit padding due to the length discrepancy. Those paddings consist of zeroes in the *plaintext*.

A client that has access to the shadow data should still download the padding data at least up to the next piece boundary (allowing paddings larger than a single piece to be partially skipped) to avoid leaking information about actual file sizes or knowledge of the file metadata.
Similarly clients should avoid prioritizing individual pieces or sequential downloading because they would otherwise reveal their knowledge of the file layout.


Encryption
==========

Building blocks used in version 1:  SHA2-256 [#rfc6234]_, ChaCha20 [#chacha]_, HMAC [#rfc2104]_, scrypt [#rfc7914]_

``||`` is the concat operator   

.. parsed-literal::

    byte[] root_key = reusable key or password from which other values are derived. recommended strength: 256bits

    byte[32] payload_key = scrypt(N: 2\ :sup:`14`\  , r: 8, p: 1, password: root_key, salt: (salt || "payload"))

    byte[32] shadow_key = sha256(payload_key || "shadow")
    
    byte[32] mac = HMAC−SHA256(message: bencode(info["length"]) || bencode(merkle_root) || bencode(info["encrypted"]), key: shadow_key)

    byte[8] payload_nonce = sha256(salt || "payload")[0..8]

    byte[8] shadow_nonce = sha256(salt || "shadow")[0..8]
    
``salt``, ``payload_key``, ``shadow_key`` and ``mac`` are 32 bytes each. The nonces are 8 bytes each. ``root_key`` does not have a fixed size.

scrypt key derivation is used in case root keys with less entropy than recommended are used, e.g. for password-based schemes. Note that arbitrary binary data is allowed for keys, so this proposal distinguishes between a key and human-readable passwords. More on that below.

ChaCha20 with a 64bit nonce, 64bit internal block counter and 256bit key is used to both encrypt the shadow dictionary and the torrent payload. A longer nonce is not needed since a new payload key is already derived for each torrent and using the alternative 96bit nonce/32bit block counter version would also limit the payload size to 256TiB.

The ``shadow`` dictionary is bencoded and then encrypted with ``shadow_key`` and ``shadow_nonce``.

The ``enc mac`` is calculated as HMAC over the concatenated bencoded representations of the ``length`` value, merkle root [#BEP-30]_ and ``encrypted`` value. The merkle root can be derived from the ``pieces`` array. This allows a torrent to be converted between merkle and flat pieces layout without access to the keys.

The encryption is applied while file data is loaded into the piece address space. Which means the ``pieces`` hashes are calculated over the ciphertext using ``payload_key`` and ``payload_nonce``.
The key stream of the cipher applied according to the absolute offset of the data in the piece space. I.e. any padding, holes or alignment in the plaintext is included in the key stream seek position.
This BEP only covers pieces representing file entries. Should future extensions put other data into the piece address space the interaction with this BEP will need to be defined.   

An implementation unaware of this BEP will simply store the ciphertext to the disk in a ``length``-sized file with the public name.

This scheme only provides integrity verification for the ciphertext through the ``pieces`` hashes, i.e. correct decryption is not verified. An incorrect key could result in garbage plaintext, but this does not introduce a new problem since bittorrent never guaranteed that the files contain what the metadata claims.

Key reuse and hierarchy
-----------------------

The salt in the payload key derivation allows the root key to be reused across several torrents while still generating distinct payload keys for each. But UI design SHOULD encourage random key generation for each new torrent and require explicit user action for key reuse.

An implementation may provide the option to attempt to decrypt a torrent with the same key as another torrent in case a key is only communicated once and individual torrents are later distributed without explicitly providing keys.

In some circumstances it may make sense to reveal a particular key lower in the hierarchy without revealing an upper key. For example a user may upload a torrent to an indexing site and provide the shadow key so it can extract keywords for fulltext search.

Or a user may want to share a particular torrent without revealing the root key used to protect multiple other torrents, in that case revealing the payload key for that torrent will be sufficient.

The mac can also be used to determine to which level of the hierarchy a key belongs by first assuming it is the shadow key and attempting to verify the info-dictionary against it, then assuming it is the payload key, deriving the shadow key and then attempting to verify it etc.

Key sharing
===========

Implementations SHOULD provide a way to view and input the different keys for a torrent so users can share them in unstructured ways. To allow for both arbitrary binary data - which is necessary for intermediate keys - and human-readable passphrases two encodings are necessary:

a) url-safe base64 encoding
b) a valid unicode string where the utf8-representation is used as root key 


Encouraging users to share keys without bundling them with torrents or magnets in a structured way allows them to exchange them over separate channels and also makes it slightly more difficult to crawl the internet for unintentionally disclosed keys.

Web services that request that users reveal keys for a specific use-case (e.g. metadata extraction) can ask for the key in a separate input field in their forms / APIs.
They SHOULD NOT store or in turn reveal the keys to visitors if that is not essential for their use-case.

Keys MUST NOT be included in .torrent files in any form. Too much infrastructure for crawling and automatic mass-distribution of .torrent files exists and to a user it would not be obvious whether a torrent contains keys or not, thus making accidental disclosure likely.

Magnets
-------

While directly including the secrets in a magnet is **discouraged** - they should be conveyed separately - this proposal nevertheless specifies a format to ensure that keys can be transmitted unambiguously when it cannot be avoided.

To include a key in magnet links the parameter ``&key=<key>`` can be added where the key is in the url-safe base64-encoded form, minus padding to avoid percent-escaping the ``=`` padding. 

The importing client can determine which type of key it is based on the ``mac`` in the metadata.

If the root key can be utf8-decoded to a valid unicode string it can also be passed as ``&pw=<password>``. Since user agents may process magnet URIs into Internationalized Resource Identifiers (IRIs) for increased readability clients should be prepared to handle IRI input.


 

Key files
---------

To export keys to a file, e.g. for archival purposes or for bulk torrent migration between clients, the following bencoded format can be used:

.. parsed-literal::

    {
      torrent-keys: [
		{
		  "key": *<binary key (string)>* 
          "hints": [
          	*<optional, torrent hint (string)>*,
          	...          
          ]
        },
        ...
      ]
    }

Each dictionary in the ``torrent-keys`` list represents one key and optional implementation-defined fields associated with that key.

*torrent hint*
  An identifier calculated from a torrent's mac via ``SHA256(mac || ".torrent-keys")[0..8]``. This allows a torrent client to locate keys for a metadata file without having to attempt key-derivation. 


``.torrent-keys`` should be used as file extension. By default filesystem permissions should be set appropriately to restrict access to key files to the current user.

A key file can contain keys for multiple torrents. Only one key needs to be included per torrent, as the lower keys can be derived. Keys must be included in their binary form.





Storage layer
=============

This BEP does not mandate how an implementation should store encrypted or decrypted data on disk.

However, if a client wants to be more flexible than either ignoring this BEP (thus storing ciphertext on disk) or always requiring the keys before starting a torrent it will have to consider the following:

* clients can be in 3 states regarding key knowledge: no keys, shadow key only, keys that can decrypt the payload; two encryption states: encrypted, decrypted; 3 file layout states: encrypted, multi-file, single-file
* a user may start downloading a torrent before keys are available. this requires a way to input keys and to convert between encrypted and decrypted storage
* for performance or security reasons a seeder may want to import plaintext data, encrypt it and then discard the keys to directly seed the encrypted data from disk.

Since encrypted torrents may contain confidential / private data implementations may also want to set more restrictive file permissions when decrypting data to reduce exposure in multi-user environments.



Security Properties
===================

The goal is to provide security equivalent to publicly distributing an encrypted archive where the file index is encrypted with a separate key that can be revealed without revealing the payload key.

In particular that means:

* swarms remain open, anyone can participate in a swarm, with or without access to the secrets
* an observer without access to the secrets can not confirm that any published metadata does indeed match the torrent
* correctness of the metadata cannot be confirmed without access to both secrets 
* observing that someone participated in a swarm and uploaded data is no longer equivalent to knowing that they had access to the plaintext or knowledge of the metadata. 
* the ciphertext is accessible to the public. this may be desirable to provide upload bandwidth without knowledge of the content, e.g. to allow untrusted servers to distribute confidential data to trusted clients, to enable hosting without the need to proactively moderate user content or to operate content-agnostic caches.


Limitations:

* there is no forward secrecy. should the secrets become available to an unauthorized party at some future point they will be able to decrypt ciphertext they have downloaded in the past and retroactively associate content with observed users
* deniability is fairly weak, if someone learns the shared secrets or has knowledge how they are distributed they may also draw conclusions whether a particular participant in a swarm could have had access to it.


UI concerns
===========

This section is advisory.

Shared secrets are handled by many parties, therefore the system is as weak as the weakest human. Thus making intentional, correct handling of secrets simple and convenient while making unintentional disclosure hard is an important aspect of keeping the system secure.

Information that a client may want to make visible:

* encrypted/decrypted status of a torrent
* which keys it knows (+ option to discard if storage is encrypted)

Torrent creation
----------------

1. user selects whether he wants to use encryption at all
2. if yes then offer to
   
   * generate a random key. user may instead opt to reuse a key from another torrent
   * provide a meaningful public name distinct from the shadow name

 
Key input
---------

* input choices: manual, magnet link, ``.torrent-keys`` file, reusing key from another torrent
* immediate feedback whether keys match the mac and what kind of key was imported (root, payload, shadow)
* option to decrypt data or leave it encrypted

  * offer directory layout choices that would normally be offered when a torrent is imported 

Magnet/Key export
-----------------

Provide option to

* not include key [default]
* include shadow key.
* include payload key.
* include root key. if the client knows that the key has been reused for other torrents it should indicate this to the user


Test Data
=========

The test data is generated as follows:

1. fill ./foo/a with 18 * 16KiB of the character ``a``
2. fill ./foo/b with 2 * 16KiB of the character ``b``
3. use root key: 0x4b6cc4770ff57005d597a8f01e83679d2f2b2ce86490ab5cf10e71f4ef7533e2
4. generated from file structure shadow dictionary::

    {
      "name":"foo", 
      "files":[
        {
          "sha1":0x5B63C06D350BB4BE82F00B170B822A7BF3F5B190, 
          "path":["a"], 
          "length":294912
        }, {
          "sha1":0x5B94E57E8BC842A56BB6BD628F3309A6D9092421, 
          "path":["b"], 
          "length":32768
        }, {
          "length":229376, 
          "attr":"p"
        }
      ]
    }
    
    

5. generated torrent from salt and previous values:

    {
      "info":{
        "pieces":0x28EC203A4435B4DAC7582B598E5A1F11F6060B7202FA5D9E68E003006697AEABF48386B6D86AA9A9, 
        "sha1":0x8B5C9069F227DED25CE1CAD65CA0DF29812BECA6, 
        "enc mac":0xF2614F94AE0408138B5ED75B45B626B3424E65A83BAB0D3468A649E5792631DA, 
        "encrypted":{
          "salt":0x1053F898E1917EAB461616F895BC2F50ADFFE48F7F4C92AD547E6849B7D27DF7, 
          "shadow":0x1508C10EF6558D344A645299E4B2C3A3FDC5FAF799FF71E9045E2617C887773D05E6458E0A14D5CC953374F7AA3C944023CD5D87C3B12E3F316FB32A1890FBE37B0F1482217B3E8B77E339D2003A12ADA04940E7BDBFA029EE652450BA512C45DFC7EC3A331FAF661D80AABE08281F2685675B5302FEBA8DE99B7453CEDE920E36C863F4860F0901FA4E99DF7840489B6C97F813F6E9FE97B2B8B19116C15367C3F1EA77, 
          "v":1
        }, 
        "length":557056, 
        "name":"Public Name", 
        "piece length":278528
      }
    }

    
  

Additional intermediate values in hex:
 
payload nonce
  381d28f55eb87e2e

shadow nonce
  3824dc7d0e71dd38

torrent key
  afaf3eb80291b13546814af8cacf0ae5150b5505e6c0633954bf9daa17363a83

metainfo key
  237b2116dc9397a053ff17811d260f02368bc0a704e558d671c33bd015e15f5f

sha1sum of the plaintext bencoded shadow dictionary
  e36ffe11188a878147ca72bf9e70b40067451333

  
Key, Password and Magnet representations
----------------------------------------

The following strings are all part of the same key hierarchy and generated using the following salt ``1db9b1aed1d3ba1d892d9afd52ea6ba158a986e785d3ed7f4203b834f499a922``

base64 root key
  ``UGFzc3fDuHJ0LeODkeOCueODr-ODvOODiQ``
  
base64 torrent key
  ``dEBBM6zLgPd8OCPCEAgtK0F55CZsOiLm_h-neGTgSY8``

base64 meta key
  ``AY81p-wPMHNSXpI1w_dMjBqETWsUzmrGXfajHjExlfY``
  
human-readable root key
  ``Passwørt-パスワード``
  
magnet with torrent key
  ``magnet:?xt=urn:btih:da39a3ee5e6b4b0d3255bfef95601890afd80709&key=dEBBM6zLgPd8OCPCEAgtK0F55CZsOiLm_h-neGTgSY8``

magnet uri with human-readable root key
  ``magnet:?xt=urn:btih:da39a3ee5e6b4b0d3255bfef95601890afd80709&pw=Passw%C3%B8rt-%E3%83%91%E3%82%B9%E3%83%AF%E3%83%BC%E3%83%89``
  
magnet iri with human-readable root key 
  ``magnet:?xt=urn:btih:da39a3ee5e6b4b0d3255bfef95601890afd80709&pw=Passwørt-パスワード``





References
==========

.. [#BEP-3] BEP_0003. The BitTorrent Protocol Specification
   (http://bittorrent.org/beps/bep_0003.html)
   
.. [#BEP-27] BEP_0027. Private Torrents
   (http://bittorrent.org/beps/bep_0027.html)

.. [#BEP-30] BEP_0030. Merkle tree torrent extension
   (http://bittorrent.org/beps/bep_0030.html)

.. [#BEP-35] BEP_0035. Torrent Signing
   (http://bittorrent.org/beps/bep_0035.html)

.. [#BEP-47] BEP_0047. Padding files and extended file attributes
   (http://bittorrent.org/beps/bep_0047.html)

.. [#chacha] ChaCha20 by Daniel J. Bernstein
   (https://cr.yp.to/chacha.html)
   
.. [#rfc6234] RFC 6234. http://www.ietf.org/rfc/rfc2119.txt

.. [#rfc2104] RFC 2104. http://www.ietf.org/rfc/rfc2104.txt

.. [#rfc7914] RFC 7914. http://www.ietf.org/rfc/rfc7914.txt

Copyright
=========

This document has been placed in the public domain.



..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:

