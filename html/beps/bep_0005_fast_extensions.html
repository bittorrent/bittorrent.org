<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-type" content="text/html; charset=utf-8" />
<title>BitTorrent.org For Developers</title>
<link rel="stylesheet" type="text/css" href="./css/screen.css" media="screen" />
</head>
<body id="www-bittorrent-org">
<div id="upper" class="clear">
<div id="wrap">
<div id="header">
<h1><a href="./index.html">BitTorrent<span>.org</span></a></h1>
</div>
<div id="nav">
<ul>
<li><a href="./index.html">Home</a></li>
<li><a href="./introduction.html">For Users</a></li>
<li><span>For Developers</span></li>
<!-- <li><a href="./blog">Blog</a></li> -->
<li><a href="./donate.html">Donate!</a></li>
</ul>
</div>
<!-- ### Begin Content ### -->
<div id="second">
<h1>Fast Extension</h1>
<p>The Fast Extension packages several extensions: <i>Have None/Have All</i>,
<i>Reject Requests</i>, <i>Suggestions</i> and <i>Allowed Fast.</i>
These are enabled by setting the third least significant bit of the
last reserved byte in the BitTorrent handshake:
</p>
<pre> reserved[7] |= 0x04
</pre>
<p>The extension is enabled only if both ends of the connection set this bit.
</p><p>The following proposed messages adhere to the syntax of messages found
in v1.0 of the BitTorrent protocol.  All integers are four bytes
big-endian.  All messages start with an integer message length.  All messages
but the Keep-Alive follow the message length with a single byte opcode
and zero or more opcode-dependant arguments.
</p><p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
"OPTIONAL" in this document are to be interpreted as described in
IETF <a href='http://www.ietf.org/rfc/rfc2119.txt' class='external' title="http://www.ietf.org/rfc/rfc2119.txt">RFC 2119</a>.
</p>
<table id='toc' class='toc'><tr><td><div id='toctitle'><h2>Contents</h2></div>
<ul>
<li class='toclevel-1'><a href="#Modifications_to_Semantics_of_Existing_Messages"><span class="tocnumber">1</span> <span class="toctext">Modifications to Semantics of Existing Messages</span></a></li>
<li class='toclevel-1'><a href="#Have_All.2FHave_None"><span class="tocnumber">2</span> <span class="toctext">Have All/Have None</span></a></li>
<li class='toclevel-1'><a href="#Suggest_Piece"><span class="tocnumber">3</span> <span class="toctext">Suggest Piece</span></a></li>
<li class='toclevel-1'><a href="#Reject_Request"><span class="tocnumber">4</span> <span class="toctext">Reject Request</span></a></li>
<li class='toclevel-1'><a href="#Allowed_Fast_Set_Generation"><span class="tocnumber">5</span> <span class="toctext">Allowed Fast Set Generation</span></a></li>
</ul>
</td></tr></table>
<p><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } </script>
</p>
<h2 id="Modifications_to_Semantics_of_Existing_Messages"> Modifications to Semantics of Existing Messages </h2>
<p>The Fast Extension modifies the semantics of the
<i>Request</i>, <i>Choke</i>, <i>Unchoke</i>, and <i>Cancel</i>
messages, and adds a <i>Reject Request.</i>  Now, every request
is guaranteed to result in EXACTLY ONE response
which is either the corresponding reject or corresponding piece
message.  Even when a request is cancelled, the peer receiving
the cancel should respond with either the corresponding reject or
the corresponding piece: requests that are being processed are
allowed to complete.
</p><p>Choke no longer implicitly rejects all pending requests,
thus eliminating some race conditions which could cause pieces
to be needlessly requested multiple times.
</p><p>Additionally, if a peer receives a piece that was never requested,
the peer MUST close the connection.
</p>
<h2 id="Have_All.2FHave_None"> Have All/Have None </h2>
<pre> <i>Have All</i>: &lt;len=0x0001&gt;&lt;op=0x0E&gt;
</pre>
<pre> <i>Have None</i>: &lt;len=0x0001&gt;&lt;op=0x0F&gt;
</pre>
<p><i>Have All</i> and <i>Have None</i> specify that the message sender
has all or none of the pieces respectively.  When present, <i>Have All</i>
or <i>Have None</i> replace the <i>Have Bitfield.</i>  Exactly one of <i>Have All</i>,
<i>Have None</i>, or <i>Have Bitfield</i> MUST appear and only immediately after
the handshake.  The reason for these messages is to save bandwidth.  Also
slightly to remove the idiosyncrasy of sending no message when a peer
has no pieces.
</p><p>When the fast extension is disabled, if a peer receives <i>Have All</i> or
<i>Have None</i> then the peer MUST close the connection.
</p>
<h2 id="Suggest_Piece"> Suggest Piece </h2>
<pre> <i>Suggest Piece</i>: &lt;len=0x0005&gt;&lt;op=0x0D&gt;&lt;index&gt;
</pre>
<p><i>Suggest Piece</i> is an advisory message meaning "you might like to
download this piece."  The intended usage is for 'super-seeding'
without throughput reduction, to avoid redundant downloads, and so that
a seed which is disk I/O bound can upload continguous or identical
pieces to avoid excessive disk seeks.  In all cases, the seed SHOULD
operate to maintain a roughly equal number of copies of each piece in
the network.  A peer MAY send more than one <i>suggest piece</i> message at
any given time.  A peer receiving multiple <i>suggest piece</i> messages
MAY interpret this as meaning that all of the suggested pieces
are equally appropriate.
</p><p>When the fast extension is disabled, if a peer receives a
<i>Suggest Piece</i> message, the peer MUST close the connection.
</p>

<h2 id="Reject_Request"> Reject Request </h2>
<pre> <i>Reject Request</i>: &lt;len=0x000D&gt;&lt;op=0x10&gt;&lt;index&gt;&lt;begin&gt;&lt;offset&gt;
</pre>
<p><i>Reject Request</i> notifies a requesting peer that its request will not be satisfied.
</p><p>If the fast extension is disabled and a peer receives a reject
request then the peer MUST close the connection.
</p><p>When the fast extension is enabled:
</p>
<ul><li> If a peer receives a reject for a request that was never sent then the peer SHOULD close the connection.
</li><li> If a peer sends a choke, it MUST reject all requests from the peer to whom the choke was sent except it SHOULD NOT reject requests for pieces that are in the <i>allowed fast set.</i>  A peer SHOULD choke first and then reject requests so that the peer receiving the choke does not re-request the pieces.
</li><li> If a peer receives a request from a peer its choking, the peer receiving the request SHOULD send a reject unless the piece is in the <i>allowed fast set.</i>
</li>
<li>If a peer receives an excessive number of requests from a peer it is choking, the peer receiving the requests MAY close the connection rather than reject the request.  However, consider that it can take several seconds for buffers to drain and messages to propagate once a peer is choked.</li></ul>

<h2 id="Allowed_Fast">Allowed Fast</h2>
<pre><i> Allowed Fast: &lt;len=0x0005&gt;&lt;op=0x11&gt;&lt;index&gt;</i></pre>
<p>With the BitTorrent protocol specified in <a href="protocol.html">[1]</a>, new peers take several minutes to ramp up before they can effectively engage in BitTorrent's tit-for-tat. The reason is simple: starting peers have few pieces to trade.</p>
<p><i>Allowed Fast</i> is an advisory message which means "if you ask for this piece, I'll give it to you even if you're choked." <i>Allowed Fast</i> thus shortens the awkward stage during which the peer obtains occasional optimistic unchokes but cannot sufficiently reciprocate to remain unchoked.</p>
<p>The pieces that can be downloaded when choked constitute a peer's <i>allowed fast set.</i> The set is generated using a canonical algorithm that produces piece indices unique to the message receiver so that if two peers offer <i>k</i> pieces fast it will be the same <i>k</i>, and if one offers <i>k+1</i> it will be the same <i>k</i> plus one more. <i>k</i> should be small enough to avoid abuse, but large enough to ramp up tit-for-tat. We currently set <i>k</i> to 10, but peers are free to change this number, e.g., to suit load.</p>
<p>The message sender MAY list pieces that the message sender does not have. The receiver MUST NOT interpret an Allowed Fast message as meaning that the message sender has the piece. This allows peers to generate and communicate allowed fast sets at the beginning of a connection. However, a peer MAY send Allowed Fast messages at any time.</p>
<p>A peer SHOULD send Allowed Fast messages to any starting peer unless the local peer lacks sufficient resources. A peer MAY reject requests for already Allowed Fast pieces if the local peer lacks sufficient resources, if the requested piece has already been sent to the requesting peer, or if the requesting peer is not a starting peer. Our current implementation rejects requests for Allowed Fast messages whenever the requesting peer has more than <i> k </i> pieces.</p>
<p> When the fast extension is disabled, if a peer recieves an Allowed Fast message then the peer MUST close the connection.</p>

<h2 id="Allowed_Fast_Set_Generation"> Allowed Fast Set Generation </h2>
<p>The canonical algorithm for computing a peer <i>P'</i>s <i>allowed fast set</i>
follows.  All integers in this pseudocode are four bytes represented in network (big-endian) byte order.  <i>[a:b]</i> denotes the sequence of consecutive bytes from <i>a</i> to <i>b</i> excluding <i>b</i>, i.e., <i>(a, a+1, a+2,..., b-1)</i>. <i>x[a:b]</i> denotes a subsequence of elements in an array <i>x</i> starting from index <i>a</i> to but not including index <i>b</i>.
</p><p>Let <i>ip</i> denote <i>P'</i>s IPv4 address.  We currently have no
provisions for IPv6. If a peer is behind a Network Address Translator
(NAT) then <i>ip</i> should be the externally facing IP address of the
NAT.  Since the node sending the <i>Allowed Fast</i> messages computes
the set, the correct <i>ip</i> is usually the <i>ip</i> address on the other
end of the connection.  The host computing the set MAY use the <i>ip</i>
address on the other end of the connection regardless
</p><p>Let <i>sz</i> denote the number of pieces in the torrent.
</p><p>Let <i>a</i> denote the allowed fast set.
</p><p>Let <i>k</i> denote the final number of pieces in the allowed fast set.
</p>
<pre> x = 0xFFFFFF00 &amp; ip                           (1)
 x.append(infohash)                            (2)
 while |a| &lt; k:
   x = SHA1(x)                                 (3)
   for i in [0:5] and |a| &lt; k:                 (4)
     j = i*4                                   (5)
     y = x[j:j+4]                              (6)
     index = y % sz                            (7)
     if index not in a:                        (8)
       add index to a                          (9)
</pre>
<p>Step (1) selects the most significant octets in peer <i>P'</i>s
ip address.  We do this to prevent a user that obtains more than one
IP address on the same network from obtaining more than one
<i>allowed fast set.</i>  Use of three bytes is heuristic and
historical.
</p><p>Step (3) generates a 20-byte random number on each call.  By
performing a SHA-1 hash on the previous iteration's hash, we can
generate an arbitrarily long pseudorandom sequence.
</p><p>Steps (4) through (9) partition the 20-byte hash into piece indices
and add them to the allowed fast set.
</p>
</div><a name="Example_Implementation"></a><h2> Example Implementation </h2>
<p>The following C++ implementation was provided by CacheLogic:
</p>
<pre>void generate_fast_set(
  uint32 k,     // number of pieces in set
  uint32 sz,    // number of pieces in torrent
  const char infohash[20], // infohash of torrent
  uint32 ip, // in host byte order, ie localhost is 0x7f000001
  std::vector&lt;uint32&gt; &amp;a) // generated set of piece indices
{
   a.clear();
   std::string x;
   char buf[4];
   *(uint32*)buf = htonl(ip &amp; 0xffffff00);
   x.assign(buf, 4);
   x.append(infohash, 20); // (3)
   while (a.size()&lt;k) {
     x = SHA1(x); // (4)
     for ( int i=0&nbsp;; i&lt;5 &amp;&amp; a.size()&lt;k&nbsp;; i++ ) { // (5)
       int j = i*4; // (6)
       uint32 y = ntohl(*(uint32*)(x.data()+j)); // (7)
       uint32 index = y % sz; // (8)
       if (std::find(a.begin(), a.end(), index)==a.end()) { // (9)
         a.push_back(index); // (10)
       }
     }
   }
}
</pre>
<p>Example results generated by this function:
</p>
<pre>7 piece allowed fast set for torrent with 1313 pieces and hex infohash
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa for node with IP 80.4.4.200:
  1059,431,808,1217,287,376,1188
9 piece allowed fast set for torrent with 1313 pieces and hex infohash
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa for node with IP 80.4.4.200:
  1059,431,808,1217,287,376,1188,353,508
</pre>
</div>

<div class="section">
 <h2><a id="authors" name="authors">authors</a></h2>
 <div class="line-block">
   <div class="line"><a class="reference" href="mailto:dave&#37;&#52;&#48;bittorrent&#46;com">David Harrison</a></div>
   <div class="line"><a class="reference" href="mailto:bram&#37;&#52;&#48;bittorrent&#46;com">Bram Cohen</a></div>
 </div>
</div>
<!-- ### End Content ### -->
</div>
</div>
<div id="footer">
<hr />
<p>Copyright 2008 BitTorrent.org</p>
</div>
</body>
</html>
