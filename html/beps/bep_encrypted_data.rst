:BEP: ??
:Title: Encrypted Torrent Payload
:Version: $Revision$
:Last-Modified: $Date$
:Author:  The 8472 <the8472.bep@infinite-source.de>
:Status:  Draft
:Type:  Standards Track
:Content-Type: text/x-rst
:Created: 04-Oct-2015
:Post-History: 


Abstract
========

This BEP specifies a way to apply symmetric encryption to torrent payload at the storage layer and additionally encrypt some metadata with the following goals:

* confidentiality 
* limited privacy

and non-goals:

* forward-secrecy
* anonymity
* signature-based authentication
* authentication of peer connections
  


Rationale
=========

BitTorrent swarms are mostly an open system well-suited for mass-distribution of data to the public.

Some use-cases require that the data is only distributed to a closed, trusted group of peers.
In other cases the content may be meant for open distribution within a community without intent of announcing the content to the whole world. This is analogous to web content that is open to human visitors but requests via robots.txt[robots]_ that it should not be announced to the world by web crawlers.   


While the private flag [BEP-27]_ may be sufficient in a controlled environment to prevent information about the torrent (e.g. its infohash) from escaping and thus preventing others from connecting to the swarm this is a very brittle form of security which also prevents the use of public infrastructure such as open trackers, PEX or the DHT.
Similarly Message Stream Encryption provides limited protection from passive eavesdroppers on the network layer but does not prevent the infohash from escaping.   


Instead of attempting to restrict access to the swarm or metadata itself this BEP proposes to simply making all data opaque to 3rd parties by encrypting it with a shared secret that is not communicated by any torrent-related protocol, i.e. must be obtained separately by the user.

In principle the same properties can be provided simply by storing the data in an encrypted archive and using nondescript filename, but that requires users to store the data twice or use additional filesystem layers to transparently access the data, which is even more cumbersome when encryption is involved. It also prevents bittorrent clients from reusing already-downloaded files in a multi-file torrent. 

Metadata format
===============


.. parsed-literal::

    {
      info: {
        bepXX: {
          probe: *<32bytes of hash output (string)>*,
          salt: *<32bytes of random binary data (string)>*,
          shadow: *<optional, bencoded-then-encrypted dictionary (string)>*
          v: <version (integer)>,
        },
        length: *<unchanged>*,
        name: *<public name (string)>*,
        piece length: *<unchanged>*
        pieces: *<N*20 bytes, piece hashes of the payload ciphertext (string)>*
      },
    }
    
    
``salt``
  the random data must be generated by a cryptographically secure RNG to avoid IV reuse.

``v``
  The current version, ``1``. New versions may be introduced by updates to this BEP if cryptographic weaknesses necessitate changes. Implementations should check if they support the version indicated in the metadata file and otherwise inform the user that they can download the data but not decrypt it.

``shadow``
  bencoded-then-encrypted dictionary of key-value pairs that shadow entries in the info dictionary. implementations should only shadow a whitelist of keys which they know to be shadowable. shadowable keys suggested by this BEP: ``files, name, comment``.

``probe``
  used to quickly verify keys

``name``
  the name field is mandatory. an implementation may either provide a random string, provide a public name that reveals less information than the actual name in the shadow dictionary or may elect to not encrypt the name at all (i.e. not have a shadow name)
    
``files``
  the files list is optional. Until an implementation knows whether a shadow file list exists it should treat a public file list as purely decorative. Only when the shadow dictionary is absent or has been decrypted can the implementation know for certain how the canonical layout for the decrypted data looks like.


To protect privacy an implementation should use shadowing for any additional keys that reveal information about the payload


Encryption
==========

Cryptographic primitives:  SHA256, AES256

    Key.root = random key

    Key.payload = PBKDF2(HMACâˆ’SHA256, Key.root, salt || "payload", 4096, 256)

    Key.shadow =  sha256(Key.payload || "shadow")
    
    probe = sha256(Key.shadow)

    IV.payload = truncate_64(sha256(salt || "payload"))

    IV.shadow = truncate_64(sha256(salt || "shadow"))


All data is encrypted with AES256-CTR, with the respective IVs occupying the first 64bits of the nonce and the AES-block counter occupying the lower 64 bits.

The optional ``shadow`` dictionary is encrypted with ``Key.shadow`` and ``IV.shadow`` .

Before calculating the ``pieces`` hashes all files are concated in ``files`` order (if there is more than one) and encrypted with ``Key.payload`` and ``IV.payload``.

Encryption/Decryption of the payload happens at a lower layer than the ``pieces`` hash calculation. I.e. ``files -(concat)-> pieces`` has been replaced with ``files -(concat)-> encryption -> pieces``.

An implementation unaware of this BEP would simply store the ciphertext to the disk in a ``length``-sized file with the public name.

This scheme only provides authentication for the ciphertext through the ``pieces`` hashes. An incorrect key could result in garbage plaintext, but this does not introduce a new problem since bittorrent never guaranteed that the files contain what the metadata claims.

Key reuse and hierarchy
-----------------------

The usage of a salt to derive the payload key from the root key allows the root key to be reused across several torrents while still generating distinct payload keys for each. But UI design SHOULD encourage random key generation for each new torrent and require explicit user action for key reuse.

An implementation may provide the option to attempt to decrypt a torrent with the same key as another torrent in case a key is only communicated once and individual torrents are later distributed without explicitly providing keys.

In some circumstances it may make sense to reveal a particular key lower in the hierarchy without revealing an upper key. For example a user may upload a torrent to an indexing site and provide the shadow key so it can extract keywords for fulltext search.

Or a user may want to share a particular torrent without revealing the root key used to protect multiple other torrents, in that case revealing the payload key for that torrent will be sufficient.

The probe value can be used to determine to which level of the hierarchy a key belongs by first assuming it is the shadow key and checking if the hash matches matches the probe, then assuming it is the payload key and then double-hashing it etc.

Key sharing
===========

Implementations SHOULD provide a way to view and input the different keys for a torrent so users can share them in an unstructured ways.

They MAY also allow a torrent to be converted between plain- and ciphertext storage mode on demand. This enables use-cases where the key is shared at a later point in time or where the user does not want to permanently keep the plaintext around.

They MAY provide a way to export/import them in a machine-readable way but SHOULD only do so after user opt-in or highlighting the secret part to avoid accidental publication.

Proposed format for magnet links ``&key=<key>`` where the key in hex-encoded form.

Similarly an implementation may include a ``bepXX key`` dictionary key in torrent root dictionary, albeit in raw binary form, if the user explicitly requests the torrent to be exported that way, e.g. for archival purposes. Since it is in the root dictionary and not the info dictionary it will not leak via metadata exchange.
But to avoid accidental publication the file should be appropriately named to highlight that it contains a secret key.

Web services that request that users reveal keys for a specific use-case (e.g. metadata extraction) SHOULD NOT rely on the .torrent format. It is less fault-prone and thus safer to specify the requested keys separately in an upload form than attempting to strip them from the torrent after they have been included.



Security Properties
===================

The goal is to provide security equivalent to publicly distributing an encrypted archive where the file index is encrypted with a separate key that can be revealed without revealing the payload key.

In particular that means:

* swarms remain open, anyone can participate in a swarm, with or without access to the secrets
* an observer without access to the secrets does not know what data is being shared
* correctness of the metadata cannot be confirmed without access to both secrets 
* observing that someone participated in a swarm and uploaded data is no longer equivalent to knowing that they had access to the plaintext or knowledge of the metadata
* the ciphertext is accessible to the public. this may be desirable to provide upload bandwidth without knowledge of the content, e.g. to allow untrusted servers to distribute confidential data to trusted clients or to enable hosting without the need to proactively moderate user content.


Limitations:

* there is no forward secrecy. should the secrets become available to an unauthorized party at some future point they will be able to decrypt ciphertext they have downloaded in the past and retroactively associate content with observed users
* deniability is fairly weak, if someone learns the shared secrets or has knowledge how it is distributed they may also draw conclusions whether a particular participant in a swarm could have had access to it.


Summary of UI concerns
======================

Torrent creation
----------------

1. user selects whether he wants to use encryption at all
2. if yes then offer
  * to generate a random key. user may instead opt to reuse a key from another torrent
  * to provide a meaningful public name distinct from the shadow name
  * to only encrypt the payload and not shadow any metadata 

 
Key input
---------

* option to use the root key of another decrypted torrent
* immediate feedback whether the key matches the probe and what kind of key it was (root, payload, shadow)

Torrent/Magnet/Key export
-------------------------

Provide option to

* not include key
* include shadow key only (if there is any shadowed metadata)
* include torrent-specific key
* include root key (decrypts X additional torrents known by client, possibly more)


Test Vectors
============

## TODO


References
==========

## TODO


Copyright
=========

This document has been placed in the public domain.



..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:

