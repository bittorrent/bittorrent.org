:BEP: ??
:Title: Encrypted Torrent Payload
:Version: $Revision$
:Last-Modified: $Date$
:Author:  The 8472 <the8472.bep@infinite-source.de>
:Status:  Draft
:Type:  Standards Track
:Content-Type: text/x-rst
:Created: 04-Oct-2015
:Post-History: 


Abstract
========

This BEP specifies a way to apply symmetric encryption to torrent payload at the storage layer and additionally encrypt some metadata with the following goals:

* confidentiality
* limited privacy

and non-goals:

* forward-secrecy
* anonymity
* signature-based authentication, already covered by [BEP 35]
* authentication of peer connections
  


Rationale
=========

BitTorrent swarms are mostly an open system well-suited for mass-distribution of data to the public.

Some use-cases require that the data is only distributed to a closed, trusted group of peers.
In other cases the content may be meant for open distribution within a community without intent of announcing the content to the whole world. This is analogous to web content that is open to human visitors but requests via robots.txt[robots]_ that it should not be announced to the world by web crawlers.   


While the private flag [BEP-27]_ may be sufficient in a controlled environment to prevent information about the torrent (e.g. its infohash) from escaping and thus preventing others from connecting to the swarm this is a very brittle form of security which also prevents the use of public infrastructure such as open trackers, PEX or the DHT.
Similarly Message Stream Encryption provides limited protection from passive eavesdroppers on the network layer but does not prevent the infohash from escaping.   


Instead of attempting to restrict access to the swarm or metadata this BEP proposes to make all data opaque to 3rd parties by encrypting it with a shared secret that is not available through any torrent-related protocol, i.e. must be obtained separately by the user.

In principle the same properties can be provided by simply storing the data in an encrypted archive and using nondescript a filename, but that requires users to store the data twice or to use additional filesystem layers to transparently access the data, which is even more cumbersome when encryption is involved. It also prevents bittorrent clients from reusing already-downloaded files in a multi-file torrent. 

Metadata format
===============


.. parsed-literal::

    {
      info: {
        bepXX: {
          mac: *<32bytes of hmac output (string)>*,
          salt: *<32bytes of random binary data (string)>*,
          shadow: *<optional, bencoded-then-encrypted dictionary (string)>*
          v: *<version (integer)>*,
        },
        length: *<unchanged>*,
        name: *<public name (string)>*,
        piece length: *<unchanged>*
        pieces: *<N*20 bytes, piece hashes of the payload ciphertext (string)>*
      },
    }


``salt``
  the random data must be generated by a cryptographically secure RNG to avoid IV reuse.

``v``
  The current version, ``1``. New versions may be introduced by updates to this BEP if cryptographic weaknesses necessitate changes. Implementations should check if they support the version indicated in the metadata file and otherwise inform the user that they can download the data but not decrypt it.

``shadow``
  bencoded-then-encrypted dictionary of key-value pairs that shadow entries in the info dictionary.
  If it is absent only the payload is encrypted and all info dictionary entries are non-shadowed.
  Implementations should only shadow a whitelist of keys which they have a shadowing strategy.
  Shadowable keys suggested by this BEP: ``length, files, name, comment``.

``mac``
  message authentication code covering the info dictionary

``name``
  the name field is a mandatory part of [BEP 3]_, therefore a placeholder MUST be provided if a shadow name is used. An implementation may either generate a random string consisting of filesystem-friendly characters or allow the user to choose a public name that reveals less information than the shadow name.

``files``, ``length``
  The shadow dictionary MAY override the single/multifile nature indicated by the public info dictionary. If it does not shadow file information then the public information is canonical.
  If the ``files`` or ``length`` are shadowed then the overall payload length MUST be consistent with the public version.
  If a shadow dictionary is present the public information should be treated as decorative / advisory until it can be determined whether it has been shadowed, i.e. until the shadow data can be decrypted. 


To protect privacy an implementation should use shadowing for any additional keys that reveal information about the payload


Encryption
==========

Cryptographic primitives:  SHA256, AES256

    Key.root = random key (recommended length: 256bits)

    Key.payload = PBKDF2(HMAC−SHA256, Key.root, salt || "payload", 4096, 256)

    Key.shadow =  sha256(Key.payload || "shadow")
    
    mac = HMAC−SHA256(<info-dict without mac>, Key.shadow)

    IV.payload = truncate_64(sha256(salt || "payload"))

    IV.shadow = truncate_64(sha256(salt || "shadow"))

AES256-CTR is used for encryption, with the respective IVs occupying the first 64bits of the nonce and the AES-block counter occupying the lower 64 bits.

The optional ``shadow`` dictionary is encrypted with ``Key.shadow`` and ``IV.shadow``.

The ``mac`` is calculated over the bencoded info-dictionary excluding the ``mac`` key value pair.

Before calculating the ``pieces`` hashes all files are concated in ``files`` order (if there is more than one) and encrypted with ``Key.payload`` and ``IV.payload``.

Encryption/Decryption of the payload happens at a lower layer than the ``pieces`` hash calculation. I.e. ``files -(concat)-> pieces`` has been replaced with ``files -(concat)-> encryption -> pieces``.

An implementation unaware of this BEP would simply store the ciphertext to the disk in a ``length``-sized file with the public name.

This scheme only provides authentication for the ciphertext through the ``pieces`` hashes. An incorrect key could result in garbage plaintext, but this does not introduce a new problem since bittorrent never guaranteed that the files contain what the metadata claims.

Key reuse and hierarchy
-----------------------

The usage of a salt to derive the payload key from the root key allows the root key to be reused across several torrents while still generating distinct payload keys for each. But UI design SHOULD encourage random key generation for each new torrent and require explicit user action for key reuse.

An implementation may provide the option to attempt to decrypt a torrent with the same key as another torrent in case a key is only communicated once and individual torrents are later distributed without explicitly providing keys.

In some circumstances it may make sense to reveal a particular key lower in the hierarchy without revealing an upper key. For example a user may upload a torrent to an indexing site and provide the shadow key so it can extract keywords for fulltext search.

Or a user may want to share a particular torrent without revealing the root key used to protect multiple other torrents, in that case revealing the payload key for that torrent will be sufficient.

The mac can also be used to determine to which level of the hierarchy a key belongs by first assuming it is the shadow key and attempting to verify the info-dictionary against it, then assuming it is the payload key, deriving the shadow key and then attempting to verify it etc.

Key sharing
===========

Implementations SHOULD provide a way to view and input the different keys for a torrent so users can share them in unstructured ways. The hex-encoded form should be used for this purpose.

Encouraging users to share keys without bundling them with torrents or magnets in a structured way allows them to exchange them over separate channels and also makes it slightly more difficult to crawl the internet for unintentionally disclosed keys.

Web services that request that users reveal keys for a specific use-case (e.g. metadata extraction) can ask for the key in a separate input field in their forms / APIs.
They SHOULD NOT store or in turn reveal the keys to visitors if that is not essential for their use-case.

Keys MUST NOT be included in .torrent files in any form. Too much infrastructure for crawling and automatic mass-distribution of .torrent files exists and to a user it would not be obvious whether a torrent contains keys or not, thus making accidental disclosure likely.

Magnets
-------

Clients should only include a key if the user explicitly requests it or if the secret part has been sufficiently highlighted to make him aware of what type of secret he is sharing.

To include a key in magnet links the parameter ``&key=<key>`` can be added where the key is in hex-encoded form.

The importing client can determine which type of key it is based on the ``mac`` in the metadata.

Key files
---------

To export keys to a file, e.g. for archival purposes or for bulk torrent migration between clients, the following bencoded format can be used:

.. parsed-literal::

    {
      torrent-keys: {
        *<20 bytes infohash>*: {
          root: *<optional (string)>*,
          payload: *<optional, 32 bytes (string)>*,
          shadow: *<optional, 32 bytes (string)>*
        },
		...
      },
    }


``.torrent-keys`` should be used as file extension. By default filesystem permissions should be set appropriately to restrict access to key files to the current user. 

A file can contain keys for multiple torrents. Only one key needs to be included per torrent, as the lower keys can be derived.



Storage layer
=============

This BEP does not mandate how an implementation should store encrypted or decrypted data on disk.

However, if a client wants to be more flexible than either ignoring this BEP (thus storing ciphertext on disk) or always requiring the keys before starting a torrent it will have to consider the following:

* clients can be in 3 different knowledge states: no keys, shadow key only, keys that decrypt plaintext; two encryption states: encrypted, decrypted; 3 file layout 3 states: encrypted, multi-file, single-fil 
* a user may start downloading a torrent before he has access to the keys. this requires a way to input keys and to convert between encrypted and decrypted storage
* to reduce the amount of data that a compromised system could reveal a seeder may want to import plaintext data, convert it to encrypted form and request that the client discards the keys.

Since encrypted torrents may contain confidential / private data implementations may also want to set more restrictive file permissions when decrypting data to reduce exposure in multi-user environments.


Security Properties
===================

The goal is to provide security equivalent to publicly distributing an encrypted archive where the file index is encrypted with a separate key that can be revealed without revealing the payload key.

In particular that means:

* swarms remain open, anyone can participate in a swarm, with or without access to the secrets
* an observer without access to the secrets does not know what data is being shared
* correctness of the metadata cannot be confirmed without access to both secrets 
* observing that someone participated in a swarm and uploaded data is no longer equivalent to knowing that they had access to the plaintext or knowledge of the metadata
* the ciphertext is accessible to the public. this may be desirable to provide upload bandwidth without knowledge of the content, e.g. to allow untrusted servers to distribute confidential data to trusted clients or to enable hosting without the need to proactively moderate user content.


Limitations:

* there is no forward secrecy. should the secrets become available to an unauthorized party at some future point they will be able to decrypt ciphertext they have downloaded in the past and retroactively associate content with observed users
* deniability is fairly weak, if someone learns the shared secrets or has knowledge how they are distributed they may also draw conclusions whether a particular participant in a swarm could have had access to it.


UI concerns
===========

This section is advisory.

Shared secrets are handled by many parties, therefore the system is as weak as the weakest human. Thus making intentional, correct handling of secrets simple and convenient while making unintentional disclosure hard is an important aspect of keeping the system secure.

Information that a client may want to make visible:

* encrypted/decrypted status of a torrent
* which keys it knows

Torrent creation
----------------

1. user selects whether he wants to use encryption at all
2. if yes then offer
  * to generate a random key. user may instead opt to reuse a key from another torrent
  * to provide a meaningful public name distinct from the shadow name
  * to only encrypt the payload and not shadow any metadata 

 
Key input
---------

* input choices: manual, magnet link, .torrent-keys file, reusing key from another torrent
* immediate feedback whether keys match the mac and what kind of key was imported (root, payload, shadow)
* option to decrypt data or leave it encrypted
  * offer directory layout choices that would normally be offered when a torrent is imported 

Magnet/Key export
-----------------

Provide option to

* not include key [default]
* include shadow key only, if there is any shadowed metadata
* include payload key.
* include root key. if the client knows that the key has been reused for other torrents it should indicate this to the user


Test Vectors
============

## TODO


References
==========

## TODO


Copyright
=========

This document has been placed in the public domain.



..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:

